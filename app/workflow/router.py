"""
API router for workflow automation endpoints
"""
from typing import Dict, List
from fastapi import APIRouter, HTTPException
from app.workflow.models import (
    TaskDiscoveryRequest,
    WorkflowQuestionsResponse,
    WorkflowGenerationRequest,
    WorkflowQuestion,
    WorkflowRoadmap,
    AIToolSearchResult
)
from app.workflow.agents import (
    generate_workflow_questions,
    search_ai_tools,
    generate_workflow_roadmap
)

router = APIRouter(prefix="/workflow", tags=["workflow"])

# In-memory session storage for workflow data
workflow_sessions: Dict[str, Dict] = {}


@router.post("/discover-task", response_model=WorkflowQuestionsResponse)
async def discover_task(request: TaskDiscoveryRequest):
    """
    Initial endpoint: User describes their mundane task
    Returns follow-up questions generated by Gemini
    """
    try:
        # Generate follow-up questions using Gemini
        questions = await generate_workflow_questions(request.user_input)
        
        # Store in session
        workflow_sessions[request.session_id] = {
            "task_input": request.user_input,
            "questions": [q.dict() for q in questions],
            "answers": {}
        }
        
        return WorkflowQuestionsResponse(
            questions=questions,
            session_id=request.session_id
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error discovering task: {str(e)}")


@router.post("/submit-answers")
async def submit_answers(session_id: str, answers: Dict[str, str]):
    """
    User submits answers to follow-up questions
    """
    try:
        if session_id not in workflow_sessions:
            raise HTTPException(status_code=404, detail="Session not found")
        
        workflow_sessions[session_id]["answers"] = answers
        
        return {"status": "success", "message": "Answers recorded"}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error submitting answers: {str(e)}")


@router.post("/search-tools", response_model=List[AIToolSearchResult])
async def search_tools_endpoint(session_id: str):
    """
    Search for AI tools using Perplexity and Tavily APIs
    """
    try:
        if session_id not in workflow_sessions:
            raise HTTPException(status_code=404, detail="Session not found")
        
        session_data = workflow_sessions[session_id]
        task_description = session_data.get("task_input", "")
        answers = session_data.get("answers", {})
        
        # Search for AI tools
        tools = await search_ai_tools(task_description, answers)
        
        # Store tools in session
        workflow_sessions[session_id]["tools"] = [tool.dict() for tool in tools]
        
        return tools
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error searching tools: {str(e)}")


@router.post("/generate-roadmap", response_model=WorkflowRoadmap)
async def generate_roadmap_endpoint(session_id: str):
    """
    Generate complete workflow roadmap using Gemini
    """
    try:
        if session_id not in workflow_sessions:
            raise HTTPException(status_code=404, detail="Session not found")
        
        session_data = workflow_sessions[session_id]
        task_description = session_data.get("task_input", "")
        answers = session_data.get("answers", {})
        
        # Get tools from session or search if not available
        tools_data = session_data.get("tools", [])
        if not tools_data:
            tools = await search_ai_tools(task_description, answers)
            workflow_sessions[session_id]["tools"] = [tool.dict() for tool in tools]
        else:
            tools = [AIToolSearchResult(**tool) for tool in tools_data]
        
        # Generate roadmap
        roadmap = await generate_workflow_roadmap(task_description, answers, tools)
        
        # Debug: Check what's in the roadmap
        roadmap_dict = roadmap.dict()
        print(f"\n{'='*80}")
        print(f"ROADMAP DATA BEING SENT TO FRONTEND:")
        print(f"{'='*80}")
        print(f"Task: {roadmap_dict['task_title']}")
        print(f"Steps: {len(roadmap_dict['steps'])}")
        if roadmap_dict['steps']:
            first_step = roadmap_dict['steps'][0]
            print(f"\nFirst Step Data:")
            print(f"  - Title: {first_step.get('title')}")
            print(f"  - related_course: {first_step.get('related_course', 'MISSING!')}")
            print(f"  - evaluator_link: {first_step.get('evaluator_link', 'MISSING!')}")
            print(f"  - quiz: {'Present' if first_step.get('quiz') else 'MISSING!'}")
        print(f"{'='*80}\n")
        
        # Store roadmap in session
        workflow_sessions[session_id]["roadmap"] = roadmap_dict
        
        return roadmap
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating roadmap: {str(e)}")


@router.get("/roadmap/{session_id}", response_model=WorkflowRoadmap)
async def get_roadmap(session_id: str):
    """
    Retrieve existing roadmap for a session
    """
    try:
        if session_id not in workflow_sessions:
            raise HTTPException(status_code=404, detail="Session not found")
        
        roadmap_data = workflow_sessions[session_id].get("roadmap")
        if not roadmap_data:
            raise HTTPException(status_code=404, detail="Roadmap not generated yet")
        
        return WorkflowRoadmap(**roadmap_data)
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error retrieving roadmap: {str(e)}")


@router.delete("/session/{session_id}")
async def clear_session(session_id: str):
    """
    Clear workflow session data
    """
    try:
        if session_id in workflow_sessions:
            del workflow_sessions[session_id]
        
        return {"status": "success", "message": "Session cleared"}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error clearing session: {str(e)}")
